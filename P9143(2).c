#include <stdio.h>

#define N 100005

long long n, ans;
long long a[N], f[N];

int main() {
    scanf("%lld", &n);
    for (int i = 1; i <= n; i++) {
        scanf("%lld", &a[i]);
    }

    int mx = 0;
    for (int i = n; i > 0; i--) {
        while (mx < a[i]) {
            mx++;
            f[mx] = (mx > 1) ? f[mx - 1] + i : i;
        }
        ans += f[a[i]];
    }
    //  这道题的思想很精妙  f[a[i]]表示第i个数做出的贡献  从大到小
    //  第一次填的是n  完成一个简简单单的初始化
    //  计算出了如果a[i]的值小于a[n]的话   那么第i个数在这个范围内的贡献
    //  那么如果这个数字大于当前已经填好的f的话   那么说明它是来更新的
    /*
        举个例子  如果a[n]是10  那么f[1...10]的值就是(1....10)之中的一个数字乘以n
        那么如果a[n-1]是9    那么n-1的贡献就是  f[9](即9*n)
        如果 a[n-2]的值是15   那么f[11]=f[10]+(n-2)    其中f[10]表示有10个（n-2）要贡献出n  余下的部分填自己
        如果 a[n-3]==18       那么f[12]=f[10]+(f[15]-f[10])+(f[18]-f[15])  三个部分组成
        第一部分f[10]表示贡献出n的大小    第二部分就是(n-2)   第三部分就是(n-3)
    */

    printf("%lld\n", ans);
    return 0;
}
